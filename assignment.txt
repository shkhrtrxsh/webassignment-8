Q.1 React is a JavaScript library for building user interfaces. It allows developers to create reusable UI components and efficiently update the user interface by using a virtual representation of the DOM (Virtual DOM). Some pros and cons of React are:

Pros:

Component-Based: React follows a component-based architecture, making it easy to reuse and maintain UI components.
Virtual DOM: React uses a virtual representation of the DOM, which allows for efficient updates and improved performance.
One-Way Data Flow: React follows a one-way data flow, making it easier to understand and debug the application's state changes.
Large Ecosystem: React has a vast ecosystem with numerous libraries and tools available for development.
JSX: React uses JSX (JavaScript XML) syntax, which combines HTML and JavaScript, enabling developers to write declarative and expressive code.
Cons:

Steep Learning Curve: React has a learning curve, especially for developers who are new to JavaScript frameworks.
Boilerplate Code: React may require writing more code compared to other libraries or frameworks.
Fragmentation: React's ecosystem has multiple options for state management, routing, and other functionalities, which can lead to fragmentation and decision fatigue.

Q.2 The Virtual DOM is a lightweight copy of the actual DOM in React. It allows React to optimize UI updates by calculating the minimal changes needed to update the actual DOM. This helps improve performance and provides a smoother user experience by reducing unnecessary DOM manipulations.

Q.3 The main difference between the Virtual DOM and the Real DOM is as follows:

Virtual DOM:

Virtual DOM is a lightweight copy of the actual DOM.
It is a JavaScript representation of the actual DOM elements.
Any changes made to the Virtual DOM are not immediately applied to the actual DOM.
React uses the Virtual DOM to efficiently update only the necessary parts of the actual DOM, minimizing the number of expensive real DOM operations.
Real DOM:

Real DOM is the actual HTML DOM (Document Object Model) generated by the browser.
It represents the structure of the web page and its elements.
Any changes made to the Real DOM directly affect the web page, triggering reflows and repaints, which can be computationally expensive.
Manipulating the Real DOM directly can be slower and less efficient compared to working with the Virtual DOM.

Q.4 In React, a component is a reusable, self-contained piece of code that encapsulates the UI and its behavior. There are two types of components:

Functional Components:
Functional components are simple JavaScript functions that receive props as input and return JSX (HTML-like) elements.
They are primarily used for presentational purposes and don't have their own state.
Functional components can be written as arrow functions or regular functions.
Class Components:
Class components are JavaScript classes that extend the React.Component class.
They have their own state and can define lifecycle methods such as componentDidMount, componentDidUpdate, etc.
Class components are used when you need to manage state or have more complex logic in your component.

Q.5 The main differences between class-based components and functional components in React are:

Class-based components:

They are defined as JavaScript classes that extend the React.Component class.
They have their own state and can manage state changes using the setState method.
They can define lifecycle methods such as componentDidMount, componentDidUpdate, etc.
They require more code compared to functional components.
Functional components:

They are simple JavaScript functions that receive props as input and return JSX elements.
They don't have their own state and rely on props for data.
They are easier to read, write, and test compared to class-based components.
They are recommended for most use cases in React and are the preferred approach when state management is not needed.

Q.6 The React component lifecycle consists of several methods that are invoked at different stages of a component's existence. The main lifecycle methods are:

componentDidMount: Invoked immediately after the component is mounted (inserted into the DOM). It is commonly used to initiate API calls or perform initial setup.
componentDidUpdate: Invoked immediately after an update occurs (props or state changes). It is used to perform side effects or update the component's state based on the new props or state values.
componentWillUnmount: Invoked immediately before the component is unmounted (removed from the DOM). It is used to clean up any resources or event listeners set up in the component.
render: Invoked whenever the component needs to be rendered. It returns the JSX elements that represent the component's UI.

Q.7 Prop drilling is a pattern in React where props are passed through multiple intermediate components that don't need the props themselves. This can lead to a large number of props being passed down the component tree, making the code harder to maintain and understand.

To avoid prop drilling, you can use the following approaches:

Use Context API: React's Context API allows you to share data between components without manually passing props through each intermediate component. It provides a way to create global state accessible to nested components.

Implement State Management Libraries: State management libraries like Redux or MobX can centralize the application's state and make it accessible to any component without prop drilling. These libraries provide a global state store that can be accessed from any component.

Component Composition: Instead of passing props through intermediate components, consider composing components in a way that keeps the necessary props closer to the components that need them. This can be achieved by breaking down the UI into smaller, reusable components and organizing them hierarchically.

By applying these approaches, you can reduce the complexity of passing props through multiple components and make your code more maintainable and scalable.

Q.8 
import React, { useState } from 'react';

const CounterApp = () => {
  const [count, setCount] = useState(0);

  const handleIncrement = () => {
    setCount(count + 1);
  };

  const handleDecrement = () => {
    setCount(count - 1);
  };

  return (
    <div>
      <h1>Counter App</h1>
      <h2>Count: {count}</h2>
      <button onClick={handleIncrement}>Increment</button>
      <button onClick={handleDecrement}>Decrement</button>
    </div>
  );
};

export default CounterApp;

Q.9
import React, { useState } from 'react';

const GitHubUserFinder = () => {
  const [username, setUsername] = useState('');
  const [userData, setUserData] = useState(null);

  const handleChange = (event) => {
    setUsername(event.target.value);
  };

  const handleSubmit = async (event) => {
    event.preventDefault();

    try {
      const response = await fetch(`https://api.github.com/users/${username}`);
      const data = await response.json();

      if (response.ok) {
        setUserData(data);
      } else {
        setUserData(null);
        console.log('Error:', data.message);
      }
    } catch (error) {
      setUserData(null);
      console.log('Error:', error.message);
    }
  };

  return (
    <div>
      <h1>GitHub User Finder</h1>
      <form onSubmit={handleSubmit}>
        <input type="text" value={username} onChange={handleChange} placeholder="Enter GitHub username" />
        <button type="submit">Find User</button>
      </form>
      {userData && (
        <div>
          <img src={userData.avatar_url} alt="User Avatar" />
          <h2>{userData.name}</h2>
          <p>Username: {userData.login}</p>
          <p>Followers: {userData.followers}</p>
          <p>Following: {userData.following}</p>
        </div>
      )}
    </div>
  );
};

export default GitHubUserFinder;

Q.10
import React, { useState, useEffect } from 'react';

const ProductList = () => {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchProducts = async () => {
      try {
        const response = await fetch('https://fakestoreapi.com/products');
        if (response.ok) {
          const data = await response.json();
          setProducts(data);
        } else {
          setError('Error fetching products');
        }
      } catch (error) {
        setError('Error fetching products');
      } finally {
        setLoading(false);
      }
    };

    fetchProducts();
  }, []);

  if (loading) {
    return <p>Loading...</p>;
  }

  if (error) {
    return <p>{error}</p>;
  }

  return (
    <div>
      <h1>Product List</h1>
      <div className="product-list">
        {products.map((product) => (
          <div key={product.id} className="product">
            <img src={product.image} alt={product.title} />
            <h3>{product.title}</h3>
            <p>Price: ${product.price}</p>
            <p>Category: {product.category}</p>
          </div>
        ))}
      </div>
    </div>
  );
};

export default ProductList;
